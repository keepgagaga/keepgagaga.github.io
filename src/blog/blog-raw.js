const blogRaw = new Map();

let firstBlogContent =
 `# 折腾的快乐

可能每个做前端的都希望有个自己的网站吧，也知道没多少人访问，但还是想建立一个，主要是自己的地方，想怎么弄都行（当然不能违法）。

而时代也从没有像如今这样为个人建站提供如此多的便利，无论是网站模板还是静态页面生成，以及云服务的发展，都为我们提供了很多方便。

而如果你实在不想花什么成本，也不想运营一个服务器，那么 GitHub Pages 服务则是首选，不需要任何成本和维护，只要你上传静态文件就行。

而相比于博客模板，我还是更喜欢自己亲自来折腾，虽然限于审美的匮乏，经常把页面搞得很丑，但这种自己写作品的过程还是很爽的，就是享受折腾的快乐。

这次博客页面直接不加修饰了，就用最基础的 HTML，反正博客的核心向来是内容，样式只是锦上添花的事情。

目标是尽量一天更新一篇，逼着自己去输出内容，毕竟不逼着自己，永远不知道自己的极限。
`

let doSomething = 
`# 得之我幸，失之我命

不可能所有的好事都让你遇见。

重要的是能把握的事尽量把握就行。

尽力了，得到了开心，得不到放宽心，然后眼光立马往别处看。

你的时间就这么几十年，每一天每一刻才是最珍贵的。

不要浪费在懊悔自责中，又不是没机会了。

无论什么时候，我们最不缺的都是机会。

多往别处看看，会发现更多惊喜的。

人生的路又不是只有一条。
`

let record = 
`# 为自己写传记

人这一辈子真的很快

以前从没想过30岁是什么场景

从没想过自己以后会干什么工作

但一转眼竟也过来了，一切都是那么顺其自然，也终于理解了什么叫车到山前必有路这句话

回想过去的岁月，最大的遗憾就是没有留下一些记录

如果能记录下自己当时的思想，当时的生活，现在回看起来一定很有意思

好在还不算晚，从现在开始没事多记录一下，也算是留下一些痕迹了，权当做给自己的晚年留点记忆
`

let flutterBugOne =
`# flutter bug ---> 有时不显示图片

今天往图片文件夹里丢了一张图片，照例 pub get 一下，然后引用，却奇怪地没有显示出来，也没有报错

怀疑是地址写错了，仔细检查了很多遍发现没有错，又 restart 了一次，还是不显示

最后只能重新 run 一遍整个项目，这时图片才显示出来，总算解决了

目前还不知道具体原因，先记录一下
`

let flutterBugTwo =
`# flutter bug --->打包后的 app 某些页面只显示一层灰色

打包后用来测试的 app 突然在点击某些页面时变成灰色，并且无法继续点击，只能杀掉 app

后来查找到原因，是因为某些错误导致的，比如图片地址为空

今天遇到的就是这种情况，设计不在，还缺了一张图，就空着了

因为这类错误在 debug 模式下不影响使用，就没在意

但是在 release 模式下就会触发页面变灰无法点击的问题，解决办法就是回到 debug 模式，把问题排查清楚再打包就行了
`

let flutterRecordOne = 
`# flutter record ---> 如何做图片缓存

网络请求的图片需要在请求完成后缓存下来留作下次使用，以减少请求次数，加快图片显示

由于没有仔细查过 SharedPreferences 是干嘛的，只是在项目中看到它可以用来存储数据，就想到了把获取到的图片转为 base64 存起来，用的时候再从存储里拿的方法

结果因为我在调试时频繁操作，导致内存溢出，去搜索才发现这个库仅仅是作为轻量级存储使用的，用来存图片很容易就会溢出

于是去找了下，发现了 cached_network_images 这个库可以做缓存

但是因为我们的图片 URL 是不会因为图片更新变化的，导致上传了新图片后也无法更新

所以只能采用在请求的 URL 后加入更新参数来触发更新缓存，这个问题算是解决了
`

let flutterRecordTwo = 
`# flutter record ---> 既要又要往往是烦恼的根源

做 app ，写网页，好不好做？

说好做挺好做的，就去写嘛，哪有写不出的效果呢？

可是有时候却很烦，为什么，因为现实的效果往往不是 demo 那么简单

demo 很多只是需要某一个功能或效果

而现实往往是既要这个也要那个

当你要这个效果时，很快就能做出来

当你要那个效果时，也很快就能做出来

但当你既想要这个效果，同时还想要那个效果时

就不是简单的 1 + 1 = 2 了

困难度往往直线上升

好在在下班前把长度不定的可拖动排序列表做完了，吐槽下，下周继续
`

let flutterRecordThree = 
`# flutter record ---> flutter build web 打包后无法加载资源

flutter 更新 2.0.0 后就立马尝试了下 web，打包后访问发现无法加载资源，导致一直白屏

后来发现是 index.html 中有一行
 
    <base href="/">

导致的，将这一行注释掉就可以了

然后在写这一篇的时候没给代码用代码块包起来，结果又查看时会自己跳到首页

检查 URL 也没错，标题也没错啊，也有做转义，就是没想到这行代码的原因...

搜索 MDN 发现 base 元素指定用于一个文档中包含的所有相对 URL 的根 URL

我们上面那行代码的意思就是后面的所有路由都是相对于根路由的，就导致总是跳转到首页
`

let flutterRecordFour = 
`# ListView item 自动铺满屏幕宽度

使用 ListView 做列表的时候会遇到一个问题，就是子项的宽度没法指定，会自适应屏幕宽度，导致一些效果没法实现

可以使用 Align 组件包裹住子组件，这样给子组件设置的宽度就生效了

另一种方式则是 ListView 和 Wrap 的组合， Wrap 负责自动换行组件，ListView 负责滚动
`

let javaScriptRecordOne = 
`# 闭包

闭包只是一个绑定了执行环境的函数

它和普通函数的区别是，它携带了执行环境

或者和类来对比的话，函数因为自身的特性，并没有完成地表达信息，因为程序不能只有方法没有状态

那么闭包在一定程度上就是为了表达状态
`

let javaScriptRecordTwo = 
`#箭头函数和普通函数的区别

最直观的区别就是写法上了，箭头函数还是比普通函数更加简洁的，能少些几个字符也算是省了一些力气

箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，定义的时候就确定并固定了

箭头函数不能作为构造函数使用，也不能使用 new 关键字，因为箭头函数没有自己的 this， 它的 this 是继承了外层环境的 this

且 this 指向永远不会改变，而作为构造函数的话 this 需要指向新创建的对象

箭头函数没有自己的 arguments 

call、apply、bind 并不会影响 this 的指向

箭头函数没有 prototype

箭头函数不能当作 Generator 函数，不能使用 yield 关键字
`

let javaScriptRecordThree = 
`# var，let 和 const 的区别

var 声明的变量存在变量提升，即变量可以在声明之前使用，但值为 undefined

let 和 const 则没有这个问题

var 不存在块级作用域，let 和 const 存在块级作用域

var 允许变量重复声明，let 和 const 在同一作用域不允许重复声明变量

const 声明一个只读的常量，其声明时就要赋值，不然会报错

但如果声明的是一个对象，对象里的属性是可以变的，原因是 const 声明的对象只保存着对象的引用地址，只要地址不变，就不会出错

我们如果想要声明一个绝对不可变的对象，可以使用 Object.freeze(obj) 冻结对象， 对于已经冻结的属性还是对象的，可以使用递归的方法全部冻结
`

blogRaw.set('折腾的快乐', firstBlogContent);
blogRaw.set('得之我幸，失之我命', doSomething);
blogRaw.set('为自己写传记', record);
blogRaw.set('flutter ---> 有时不显示图片', flutterBugOne);
blogRaw.set('flutter ---> 打包后的 app 某些页面只显示一层灰色', flutterBugTwo);
blogRaw.set('flutter ---> 缓存图片', flutterRecordOne);
blogRaw.set('flutter ---> 既要又要往往是烦恼的根源', flutterRecordTwo);
blogRaw.set('flutter ---> flutter build web后无法加载资源', flutterRecordThree);
blogRaw.set('flutter ---> ListView item 自动铺满屏幕宽度', flutterRecordFour);
blogRaw.set('javaScript ---> 闭包', javaScriptRecordOne);
blogRaw.set('javaScript ---> 箭头函数和普通函数的区别', javaScriptRecordTwo);
blogRaw.set('javaScript ---> var， let 和 const 的区别', javaScriptRecordThree);