[{"categories":null,"content":"最近日常逛TK教主的微博，发现教主在抽奖一本《Python黑帽子：黑客与渗透测试编程之道（第2版）》，本着一颗折腾的心，就去微信读书翻了下，竟然觉得挺有意思，正好快五一了，也不能出去玩，想着不如五一折腾下渗透技术，顺便学习了解下python。\n首先就是安装 kali linux, 这是个集成了很多渗透工具的基于 debian 的 Linux 发行版，不仅功能强大，颜值也很高：）\n由于手头上没有专门的机器来安装，于是就只能用虚拟机来安装。\n先从 kali 官网下载 iso 镜像，选择推荐的 Bare Metal 选项，之后根据自己的电脑选择不同版本，如64位、32位、Apple M1 版等。\n由于我现在手上用的是 M1 芯片的本子，也没有其他机器，只能选择 M1 版本的。\n下载完成后，我们需要一个虚拟机工具，这里选择 UTM（没什么特别的，就是刚好找到了它，然后它也正好能用：）\n然后就是安装 UTM，打开–\u003e新建虚拟机–\u003e选择Linux–\u003e选择内存大小–\u003e选择硬盘大小–\u003e共享目录（跳过，不设置）–\u003e在摘要里设置虚拟机名字（其他不动）–\u003e保存。\n接下来就是点击虚拟机运行图标，进入安装虚拟机界面，在这里我选择的是图形化安装，不得不说 kali 的安装引导做得非常好，不需要你去疑惑猜测，顺着官方的推荐来就行，很快安装完毕。\n然后回到虚拟机管理界面，在 CD/DVD 选项中选择清除，将 ISO 文件清理掉，这样再次进入的时候就不会再进入安装引导界面了。\n进入 Kali Linux 界面，不能不说 Kali 的颜值是我喜欢的类型，看着比 ubuntu 舒服多了：）\n常规操作，进来先更新一波软件，但由于一些软件的依赖问题，导致不能正常更新，于是只能使用 sudo apt full-upgrade -y 来更新了…\n于是，十几分钟后你就拥有了一台 kali 虚拟机可以玩耍了。\n初步使用起来感觉还不错，有种小巧精致的感觉，以后拿来做日常 Linux 版本使用也不错哦。\n后续再更新渗透的技术学习笔记。\n","description":"","tags":null,"title":"Kali_linux_install","uri":"/posts/kali_linux_install/"},{"categories":null,"content":"","description":"","tags":null,"title":"Flutter_i18n","uri":"/posts/flutter_i18n/"},{"categories":null,"content":"很早之前找到的一个方案，使用下来感觉没啥毛病，除了每个页面都要引入麻烦些，原方案还拓展了 int，但感觉 double 能兼容 int 的绝大部分场景，偷个懒就只用 double 了。\n使用的时候按照设计图当前的尺寸改一下 standardWidth ，比如这里的意思就是当前设计图的尺寸是按 750 宽度设计的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  class SizeFit { static late MediaQueryData _mediaQueryData; static late double screenWidth; static late double screenHeight; static late double rpx; static late double px; static void initialize(BuildContext context, {double standardWidth = 750}) { _mediaQueryData = MediaQuery.of(context); screenWidth = _mediaQueryData.size.width; screenHeight = _mediaQueryData.size.height; rpx = screenWidth / standardWidth; px = screenWidth / standardWidth * 2; } // 按照像素来设置  static double setPx(double size) { return SizeFit.rpx * size * 2; } // 按照rpx来设置  static double setRpx(double size) { return SizeFit.rpx * size; } } extension DoubleFit on double { double get px { return SizeFit.setPx(this); } double get rpx { return SizeFit.setRpx(this); } } // use  Widget build(BuildContext context) { SizeFit.initialize(context); return Container( width: 100.rpx, height: 100.rpx, color: Colors.red, ); }   ","description":"","tags":null,"title":"Flutter_responsive","uri":"/posts/flutter_responsive/"},{"categories":null,"content":"下拉刷新 最简单的方法，使用 RefreshIndicator 组件，在 onRefresh 里刷新数据即可\n上拉加载更多 通过获取 ScrollController 的 maxScrollExtent 来确定有没有到底，然后在此基础上做加载更多的操作\n","description":"","tags":null,"title":"Flutter_pulldown_refresh_and_reach__bottom","uri":"/posts/flutter_pulldown_refresh_and_reach__bottom/"},{"categories":null,"content":"有很多标签和属性都是以前遇到但熟视无睹的，因为很多时候并不影响功能实现，都是选择性无视的，但闲来无事的时候还是想搞清楚这些奇奇怪怪的东西都是干嘛的。\n og 属性  1  \u003cmeta property=\"og:site_name\" content=\"...\" /\u003e    专为苹果设备优化的信息  1  \u003cmeta name=\"apple-mobile-web-app-title\" content=\"...\" /\u003e    theme  1  \u003cmeta name=\"theme-color\" content=\"#ffffff\" /\u003e   这是 Apple 状态栏颜色元标记的适当 Web 标准式等效物。它告诉浏览器为周围的 UI 设置主题。Android 上的 Chrome 和桌面上的 Brave 在这方面都做得很好。您可以在内容中放置任何 CSS 颜色，甚至可以使用该media属性仅针对特定媒体查询显示此颜色，例如支持深色主题。您还可以在 Web 应用清单中定义此属性和其他属性。\n origin-trial  1  \u003cmeta http-equiv=\"origin-trial\" content=\"...\" /\u003e    text-size-adjust  1  html{-ms-text-size-adjust:100%;-webkit-text...   假设您没有移动响应站点，并且您在小屏幕上打开它，因此浏览器可能会调整文本大小以使其更大以便更易于阅读。CSStext-size-adjust属性可以使用值 none 禁用此功能，也可以指定允许浏览器放大文本的百分比。\n body{margin:0;}  因为不同的浏览器具有不同的默认样式（用户代理样式表），您希望通过重置属性来覆盖它们，以便您的网站在不同设备上看起来相同。在这种情况下，Twitter 告诉浏览器删除 body 标签的默认边距。这只是为了减少浏览器的不一致，但我更喜欢规范化样式而不是重置它们，即跨浏览器应用相同的默认值而不是完全删除它们。人们甚至过去使用* { margin: 0 }它完全是矫枉过正并且对性能不利，但现在导入类似normalize.cssor reset.css（甚至更新的东西）并从那里开始是很常见的\n    告诉浏览器用户可以将 Twitter 添加为搜索引擎。\n    有许多可以讨论的有趣属性，尤其是nonce.\n    用于国际登陆页面。\n :focus:not([data-focusvisible-polyfill]){outline: none;}  用于在不使用键盘导航时移除焦点轮廓（CSS:focus-visible选择器在此处填充）。\n","description":"","tags":null,"title":"旧识新知","uri":"/posts/old-knowledge-new-know/"},{"categories":null,"content":"记录一些常用的布局方式，以及布局的一些细节。\n grid 布局  1    ","description":"","tags":null,"title":"Css Layouts","uri":"/posts/css-layouts/"},{"categories":null,"content":"采用把 Flutter SDK 及 Flutter 代码通过 CocoaPods 嵌入 iOS 工程里的方法，这种方法要求本地要有 Flutter 开发环境。\nbug one: iOS 项目可以在真机上运行，但在模拟器上运行就会出现 No such module ‘FlutterPluginRegistrant’ error。\n","description":"","tags":null,"title":"Ios_mix_flutter","uri":"/posts/ios_mix_flutter/"},{"categories":null,"content":"遇到一个一环扣一环的坑，真的是绝了。\n在做支付，支付完成后回到订单页面查询是否支付成功，然后更新总金额，但是遇到个诡异的事，成功获取总额后 setState 页面并没有更新总额，还是支付前的金额。\n一步步排查，金额获取到了，是对的，也执行了 setState，也重新 build 了页面，还是不行。\n就在看 build 部分的时候，突然发现热更新后也重新 build 了一次，而 setState 也会触发 build，但由于页面导航我在后面切换成了命名路由，于是接收页面参数的代码就放在了 build 方法里，然后这就会导致使用新的数据重新 build 时，前脚刚把数据更新成新的金额，后脚就在 build 时传入了路由带来的初始数据，于是页面的金额就怎么都不会改变了。\n解决方法就是把获取命名路由参数的步骤提到 initState 方法里，但直接放进去肯定会报错，因为这时候页面还没有绘制好，所以要用 Future.delayed(Duration.zero, () {}) 来包住，这样就可以了。\n","description":"","tags":null,"title":"route and applifecycle","uri":"/posts/route_applifecycle/"},{"categories":null,"content":"博客最难的不是搭建，如今在博客模版+GitHub的帮助下，搭建一个博客从未如此简单。\n困难的是写。算上从18年开始第一次折腾博客，到现在也三四年了，但真正写出来的文章屈指可数。\n我有点强迫症，经常会在一些小事情上纠结，比如GitHub账号名我已经修改了不下四五次了，博客模版也折腾好几个，都不太满意，从最早的rails搭建的博客，到express搭建的博客，再到博客模版+GitHub Page，强迫症太难受了。\n好在如今终于明白，对于博客来说，最重要的是去记录，是留下自己过去的痕迹，让自己在三年五年之后还能回忆起当初是如何思考的，虽然有很大概率会觉得之前的想法很蠢，但却不失为一种独特的记忆，毕竟，如果今天能看到小学时候的日记，我想无论当初的记录多蠢，我们都会怀念吧。\n","description":"","tags":null,"title":"开始记录","uri":"/posts/first/"}]
